grammar BiolangualParser
  rule expressions
    (expression / empty_line)*
    { def to_ast
        asts = elements.select { |e| e.respond_to? :to_ast }.map { |e| e.to_ast }
        if asts.length == 1
          asts[0]
        else
          {type: :expressions, expressions: asts}
        end
      end
    }
  end

  rule expression
    whitespace
    first:(literal / message)
    rest:(whitespace message)*
    whitespace
    "\n"?
    { def to_ast
        rest_asts = rest.elements.map { |e| e.message.to_ast }
        {type: :expression, messages: [first.to_ast, *rest_asts]}
      end
    }
  end

  rule literal
    number / string
  end

  rule number
    [0-9]+ ("." [0-9]+)?
    { def to_ast
        {type: :number, value: text_value.to_f}
      end
    }
  end

  rule string
    '"' chars:string_char* '"'
    { def to_ast
        value = chars.elements.map { |c| c.ruby_value }.join
        {type: :string, value: value}
      end
    }
  end

  rule string_char
    ('\t' / '\n' / '\r' / '\"' / [^"])
    {
      def ruby_value
        map = {
          '\t' => "\t",
          '\n' => "\n",
          '\r' => "\r",
          '\"' => "\"",
        }
        map[text_value] || text_value
      end
    }
  end

  rule message
    parentheses_message / token_message
  end

  rule parentheses_message
    '(' multiline_whitespace ')'
    { def to_ast
        {type: :message, name: '()', arguments: []}
      end
    }
    /
    '(' paren_args ')'
    { def to_ast
        {type: :message, name: '()', arguments: paren_args.to_ruby}
      end
    }
  end

  rule paren_args
    left:(expressions whitespace ',')*
    right:expressions whitespace ','? whitespace
    { def to_ruby
        if elements.empty?
          []
        else
          [*left.elements.map(&:expressions), right].map(&:to_ast)
        end
      end
    }
  end

  rule token_message
    [^ ,()\n]+
    { def to_ast
        {type: :message, name: text_value, arguments: []}
      end
    }
  end

  rule whitespace
    [ \t]*
  end

  rule multiline_whitespace
    [ \t\n]*
  end

  rule empty_line
    (whitespace "\n")
  end
end
